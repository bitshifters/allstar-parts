Verse-chorus-verse. Aka Into the Archie-Verse.
~~~
An Archimedes demo framework.
Contains all accumulated libraries and code from previous prods.

Framework TODOs as of 15/5/24:
~~~
=> Add logo on screen and submit as blank framework. - DONE
- Separate tick/draw order from being tied together.
    - Strict draw order in layers.
    - Are there any dependencies between tick?
      => Could be if moving objects in a scene then doing collisions, say.
    - Tick just means 'call this function every frame without fail'
      Could be implemented using script_fork!!
- Improve build using Tom's Python scripts and makefile-foo.
- Does ErrorV actually do anything? => Handles OS_GenerateError calls.
- Move png2arc to Python 3.
- MOD file analyser to configure code / script.
- Move scripting to use seconds throughout?
- Create text-pool module from code in fx/bits.asm. - DONE
  => (but could still maybe do with some refactoring)
- Automatic clearing of BSS by loader?

And as of 6/6/24:
~~~
- Remove OS_Byte VDU calls - just manage screen buffer data internally.
  No point in keeping these if poking VIDC directly for palette as not compatible.
  Keep a list of screen buffer addresses and set MEMC on vsync etc.
- Dynamically generate CLS code include clear line code.
    => Shrinkler does a better job of compressing this unrolled code than generating it...!!!
- How have I got this far without memcpy and memclr?!
  => Write optimised versions of these for lib. - DONE SIMPLE VERSION
- Standardise code generation at init. - DONE
    - Have R12=start of free RAM and expect to return top in R12 for next fn.


ArchieKlang Announcetro
~~~
=> Like the oscilloscope view more when all channels are combined together.
    Kinda want this to fade?

Try?
- Lines not dots (expensive?) - DONE
- Previous buffers plotted above/below in darker colour to fade out? - DONE
- Use a Y buffer so they don't overlap? - DONE
- Add palette fade as lines move up.
- Custom faster line algo. - DONE
- More lines but with smaller amplitude - DONE
- Add 'zero' signal left and right of the wave lines - DONE
- Add header text - DONE
- Fade in header messages at the top (separate colour)
- Add iterator to header?
    - Looks meh. :\
- Simple scroller at the bottom? - DONE
    - Use RISCOS font? Corpus is fixed width (but might look meh?)
    - Still need to figure out how to draw at the same Y pos for all glyphs. - DONE
    - (Write a word with ascenders and descenders then grab the max height)
    - Still need to work out which Y to plot at though! - DONE
    ==> This is not going to work even with fixed width font due to kerning.
    ==> Either use a traditional font or plot one word at a time from the scrolltext... - DONE
    ==> Make a rough calculation of how much RAM this would be... - A LOT :)
- Move scroll text to own code module and separate from text_pool API - DONE
- Sort out outline_font vs text_pool APIs - LATER
    - Separate paint to screen from copy from screen to sprite.
    - Something like:
        outline_font_paint_to_screen
        sprite_utils_make_from_screen (copying in row or column order)
        remove use of text_pool by outline_scroller.
    => AM I MAKING THIS MORE COMPLICATED? JUST ADD THEM AFTER AND STORE THE ENTRY NUMBER SOMEHOW?
       NEXT TIME: Sort out text pool vs sprite pool etc.

- Have sequence start by fading in 'BITSHIFTERS' 'ALCATRAZ' 'present' etc. - DONE
    - Then start scroll text in the same slot.
- Possible to slow the scroller down? - DONE
    - Scroll rows one byte at a time in sw and just plot right hand columns?
    - What about double/triple buffers? - JUST DOUBLE
- Add ArchieKlang sample gen at some point! - DONE
- Plot samples as they're generated? Use same effect?
    - Plot and move after each one? Hmmm!

TO FINISH
~~~
- Add fade to static header text. - DONE
- Add dynamic speed control to the scroller, otherwise it's a bit monotonous. - DONE
- Add some nice colour palette fades across the track. - IN PROGRESS
- BONUS: More colour palettes to cycle through?
- Get the final tune?!?!?! (Probably last minute... ;) => Rhino!
- Final scrolltext => get a few words from Virgill & Rhino. - DONE
- What to do about audio filter mod? => Steve?!
- BUG: Check first frame glitches ==> loader to zero BSS? No, already zero'd. Hmm.
- BUG: Wave peak leaks into fixed scroller area and gets dragged... - HACK IT! :)
- BUG: Base line drawn in colour 14 at offset 0 => flickers with certain palettes - DONE
- BUG: First frame sometimes displayed before palette is set - race condition?
- Add control code for additional spaces in scroller? - DONE
- Fade out at the end rather than loop for compo? => wait final tune.
- BUG! Scroller is at 25Hz not 50Hz!! WHAT?! - DONE
- BUG: Turn off flashing cursor in loader. - DONE
- Rename !folder to !ArchieKlang and add icon. - DONE
- Write a !Help file to explain where to find AmigaKlang etc.
- Tidy up the new build of AmigaKlangGUI and send to Virgill.


BONUS
~~~
- Generate any repeated code at runtime, e.g. cls, scroller shifts.
- Multiply scale of each line by a dynamic value. - STARTED
    - sin(camera a) so can 'look down' on the scope waves / contours.
        => dynamically changing the scale looks nice and emphasizes the y buffer effect.
        => doesn't have the effect of tilting the view 'towards' the camera.
           Need to run through the perspective equation.
           Can't really do a divide per Y value. Well....
    - sin(ypos - centre) so looks like it rotates around a cylinder.
    - Could do different scale per line. <== BONUS!
- Remove divide call from arcmusic - it's always 32767/const - DONE
- Use a proper modulo fn. for scope scroll, not a loop. - DONE
- Try having the live waveform NOT moving with the others? - DONE
- Does it look better without the flat lines on the left/right? => small border looks best.
- Dynamically cut down version for ARM2 machines? Party version can be 12MHz. - DONE AS COMPILE OPTION FOR NOW
    - Fewer samples => doesn't have much effect on overall perf => linedraw bound.
    - Fewer lines => biggest impact.
    - Need to change scopes to 8/14 :(
    - Probably also shrink text size
    - Actually switching to 32 samples for the waveform but keeping the dx=4
      makes the waveform part smaller and looks cool enough!
      Can reduce scopes to 11/11 or higher!
- Dynamically set sample speed for ARM2/ARM250+ machines for highest quality.
    - DONE AS COMPILE OPTION FOR NOW

Line segment drawing.
dx is fixed == 4 (or whatever)
dy limited: -128 <= dy <= 127
Line segments are connected.

Use MODE 12.
Unroll all 256 possible code paths.
Just do Bresenham, steep and shallow paths with
x+=1:y+=0 => strb r4, [r11], #1
x+=1:y+=1 => strb r4, [r11], #-ScreenStride+1
x+=1:y-=1 => strb r4, [r11], #ScreenStride+1
x+=0:y+=1 => strb r4, [r11], #-ScreenStride
x+=0:y-=1 => strb r4, [r11], #ScreenStride

Fantasy Cracktro Compo
~~~
Target 16th March ~five weeks!
Use RasterMan => music bug? (See Steve's email)
Get a chip tune => get something running first
Sine scroller => started
Add rasters => started
    - Raster bars?
Some ASCII text effect
Something in the background?
    - Starfield?
    - 3D starfield?
    - Particle system of some sort?
    - Line effect of some sort?
Logo! => Ask on the Atari forum if Jade will make one?


Scroller
- MODE 9 for raster colours.
- 1 byte columns = 2 pixel scroll, not per pixel
- 16x16 font = 1 byte x 16 rows x 8 x cols

ldmia r11!, {r0-r3}     ; 16 bytes
strb r0, [r12], #160
mov r0, r0, lsr #8
strb r0, [r12], #160
...
; repeat x16

Rasters
Classic hue table
R > Y > G > C > B > M > R
0x00f > 0x0ff > 0x0f0 > 0xff0 > 0xf00 > 0xf0f > 0x00f

ASCII text
- 8x8 font plotting say 20x16 ish to the screen for messages.
- Text types out one character at a time.
- Start by plotting in fixed location
- Add movement
     - Per character? => SLOW as has to be masked (4x RAM access)
     - Or somehow per pixel?

What do we want the effect to be?
If not separate characters could blit to a texture buffer.
Then how to get the texture to the screen.
Moving as a single fixed block isn't interesting.
    - Trivial on Amiga as this will be on a separate bitplane.
Ideally would want it mapped to a nice 'flag'
    - Alternatively make text out of particles cf. Push
    - Some sort of 5x7 font made out of independent dots.
    - Max 35 points, but average say 16 points?
    - Push uses 500 particles per frame = ~30 letters.
    - Hmm, not really enough. TextBox current 24x12=288 chars.

Or do something more like Hoffman's Cracktro text effect?
So use the whole high-res screen (80 column) but fixed.
That'd be in MODE 12? => Double pixels for the scroller (twice the cost...)
Would need to plot these to a third buffer and blit it instead of CLS.
Don't want to be plotting 80x32 chars individually each frame.
=> Ask ne7 for some ASCII screens!
Maybe have enough time to blit some sprites on top (vector balls ish?)
==> ALL TOO SLOW :(

Regroup
~~~
Trying to ape bitplanes on Archie is a path to madness!!!
E.g. just having a screen of static text behind everything else is
trivial on Amiga (1 independent bit plane) but painful on Archie as
everything has to be masked.

Really need to focus on what Archie is good at - not bitplanes!!

If using RasterMan then let's explore this more.
Not tried the MEMC writes to change screen address per line.
=> Wibbling logo 'for free' by selecting from preshifting 16 copies (one byte each)
=> Wibbling reflection plane at bottom of the screen by selecting from main screen

MEMC writes - can't set VInit other than on new frame.
But can set VStart and VEnd!
When Vptr > VEnd then wraps to VStart.
Vptr+=1 => 16 bytes.
All addresses are physical RAM.
Thankfully VStart typically = 0x0000
VEnd = 0x13ff = 2 * 0xA00 - 1 = 2x 40K screens - 16 bytes

==> Separate ponder. I wonder if it's possible to VRup the VIDC?
A: No! VSync always happens when Vcounter resets to 0.
   (But you can reset a load of registers midframe anyway.)
    https://stardot.org.uk/forums/viewtopic.php?p=425369 

How about a large lit torus clipped with a header logo and a scroller text below?
=> YES! :)

Cross product.
| i  j  k  |
| x0 y0 z0 |
| x1 y1 z1 |

i (y0*z1) - (z0*y1)
-j (x0*z1) - (z0*x1)
k (x0*y1) - (y0*x1)

Then have to get the length of this and normalise. Urgh.

A = [-2.34 0.0 5.65 ]
B = [ -40.0 40.0 0.0 ]
A^B = [ -226.25 -226.25 -93.75 ]

Ring starts rhs X+ve Y=0 goes down
Circle starts outer edge Z=0 X+ve Y+ve goes inside

(outside edge) 0 1 (bottom edge) 2 3 (inside edge) 4 5 (top edge) 6 7 (outside edge)
So draw order would be: 3 4 2 5 1 6 0 7
Could rotate these 180 degrees: 0 7 1 6 2 5 3 4
0 N-1
i DIV 2 (N-1)-(i DIV 2)

- Coordinates are upside down? (Y inverted?) - FIXED
    => Check transformed verts on frame 0.
       Looks like Y is upside down? YES. FFS.
    => Move to Sarah's matrix transform for verts. - DONE

- Face normals pointing the wrong way?! - FIXED
    => Check winding order! - DONE

- Performance
    => largest torus at 50Hz at 8MHz? ==> NOT MUCH!
    => cheaper scroller?
    => all micro-optimisations in loop
- Sorting
    => create front and back facing presorted face list
    => pick face list based on direction torus is pointing

More broadly?
Triangle strip approach?
Read a list of verts interleaved with colour word to plot?
=> 2D or 3D? 2D verts ultimately have to be sorted top-to-bottom
Will the cost of writing this out be higher than doing it inline?
Perhaps reduces register pressure?
Worth testing but in harness...


Sarah's vertex transform code.
~~~
Precision is possibly s7.12

; R14=count (down)
transform_loop:
        LDMIA r12!, {r9, r10} ;x, y
        ORR r12, r14, r12, LSL #11  ; count | src_ptr << 11 (free up r14)

        ;r0-r8 - matrix
        ;r9, r10 - x, y
        ;r11 - temp
        ;r12 - source ptr
        ;r14 - temp

        MUL r11, r9, r6   ;z=x*m20 + y*m21
        MLA r11, r10, r7, r11

        MUL r14, r10, r1  ;x = y*m01

        MUL r10, r4, r10     ;y = y*m11
        MLA r10, r3, r9, r10 ;y = x*m00 + y*m11

        MLA r9, r0, r9, r14 ;x = x*m00 + y*m01

        MOV r14, r12, LSR #11   ; extract src_ptr
        LDR r14, [r14]  ;z
        ADD r12, r12, #4<<11    ; increment embeded src_ptr

        MLA r9, r2, r14, r9   ;x = x*m00 + y*m01 + z*m02
        MLA r10, r5, r14, r10 ;y = x*m01 + y*m11 + z*m12
        MLA r11, r8, r14, r11 ;z = x*m02 + y*m21 + z*m22        

        MOV r14, r12, LSL #(32-11)
        MOV r14, r14, LSR #(32-11)  ; extract count
        MOV r12, r12, LSR #11       ; extract src_ptr

        MOV r9, r9, ASR #12         ; s7.12 after MUL
        MOV r10, r10, ASR #12
        MOV r11, r11, ASR #12
        STMDB sp!, {r9, r10, r11}   ; push on stack

        SUBS r14, r14, #1
        BNE transform_loop
