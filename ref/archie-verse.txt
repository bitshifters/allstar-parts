Verse-chorus-verse. Aka Into the Archie-Verse.
~~~
An Archimedes demo framework.
Contains all accumulated libraries and code from previous prods.

Framework TODOs as of 15/5/24:
~~~
=> Add logo on screen and submit as blank framework. - DONE
- Separate tick/draw order from being tied together. <=== THIS
    - Strict draw order in layers.
    - Are there any dependencies between tick?
      => Could be if moving objects in a scene then doing collisions, say.
    - Tick just means 'call this function every frame without fail'
      Could be implemented using script_fork!!
- Improve build using Tom's Python scripts and makefile-foo.
- Does ErrorV actually do anything? => Handles OS_GenerateError calls.
- Move png2arc to Python 3. ==> Use Gemini!
- MOD file analyser to configure code / script.
- Move scripting to use seconds throughout?
- Create text-pool module from code in fx/bits.asm. - DONE
  => (but could still maybe do with some refactoring)
- Automatic clearing of BSS by loader?

And as of 6/6/24:
~~~
- Remove OS_Byte VDU calls - just manage screen buffer data internally.
  No point in keeping these if poking VIDC directly for palette as not compatible.
  Keep a list of screen buffer addresses and set MEMC on vsync etc.
- Dynamically generate CLS code include clear line code.
    => Shrinkler does a better job of compressing this unrolled code than generating it...!!!
- How have I got this far without memcpy and memclr?!
  => Write optimised versions of these for lib. - DONE SIMPLE VERSION
- Standardise code generation at init. - DONE
    - Have R12=start of free RAM and expect to return top in R12 for next fn.


ArchieKlang Announcetro
~~~
=> Like the oscilloscope view more when all channels are combined together.
    Kinda want this to fade?

Try?
- Lines not dots (expensive?) - DONE
- Previous buffers plotted above/below in darker colour to fade out? - DONE
- Use a Y buffer so they don't overlap? - DONE
- Add palette fade as lines move up.
- Custom faster line algo. - DONE
- More lines but with smaller amplitude - DONE
- Add 'zero' signal left and right of the wave lines - DONE
- Add header text - DONE
- Fade in header messages at the top (separate colour)
- Add iterator to header?
    - Looks meh. :\
- Simple scroller at the bottom? - DONE
    - Use RISCOS font? Corpus is fixed width (but might look meh?)
    - Still need to figure out how to draw at the same Y pos for all glyphs. - DONE
    - (Write a word with ascenders and descenders then grab the max height)
    - Still need to work out which Y to plot at though! - DONE
    ==> This is not going to work even with fixed width font due to kerning.
    ==> Either use a traditional font or plot one word at a time from the scrolltext... - DONE
    ==> Make a rough calculation of how much RAM this would be... - A LOT :)
- Move scroll text to own code module and separate from text_pool API - DONE
- Sort out outline_font vs text_pool APIs - LATER
    - Separate paint to screen from copy from screen to sprite.
    - Something like:
        outline_font_paint_to_screen
        sprite_utils_make_from_screen (copying in row or column order)
        remove use of text_pool by outline_scroller.
    => AM I MAKING THIS MORE COMPLICATED? JUST ADD THEM AFTER AND STORE THE ENTRY NUMBER SOMEHOW?
       NEXT TIME: Sort out text pool vs sprite pool etc.

- Have sequence start by fading in 'BITSHIFTERS' 'ALCATRAZ' 'present' etc. - DONE
    - Then start scroll text in the same slot.
- Possible to slow the scroller down? - DONE
    - Scroll rows one byte at a time in sw and just plot right hand columns?
    - What about double/triple buffers? - JUST DOUBLE
- Add ArchieKlang sample gen at some point! - DONE
- Plot samples as they're generated? Use same effect?
    - Plot and move after each one? Hmmm!

TO FINISH
~~~
- Add fade to static header text. - DONE
- Add dynamic speed control to the scroller, otherwise it's a bit monotonous. - DONE
- Add some nice colour palette fades across the track. - IN PROGRESS
- BONUS: More colour palettes to cycle through?
- Get the final tune?!?!?! (Probably last minute... ;) => Rhino!
- Final scrolltext => get a few words from Virgill & Rhino. - DONE
- What to do about audio filter mod? => Steve?!
- BUG: Check first frame glitches ==> loader to zero BSS? No, already zero'd. Hmm.
- BUG: Wave peak leaks into fixed scroller area and gets dragged... - HACK IT! :)
- BUG: Base line drawn in colour 14 at offset 0 => flickers with certain palettes - DONE
- BUG: First frame sometimes displayed before palette is set - race condition?
- Add control code for additional spaces in scroller? - DONE
- Fade out at the end rather than loop for compo? => wait final tune.
- BUG! Scroller is at 25Hz not 50Hz!! WHAT?! - DONE
- BUG: Turn off flashing cursor in loader. - DONE
- Rename !folder to !ArchieKlang and add icon. - DONE
- Write a !Help file to explain where to find AmigaKlang etc.
- Tidy up the new build of AmigaKlangGUI and send to Virgill.


BONUS
~~~
- Generate any repeated code at runtime, e.g. cls, scroller shifts.
- Multiply scale of each line by a dynamic value. - STARTED
    - sin(camera a) so can 'look down' on the scope waves / contours.
        => dynamically changing the scale looks nice and emphasizes the y buffer effect.
        => doesn't have the effect of tilting the view 'towards' the camera.
           Need to run through the perspective equation.
           Can't really do a divide per Y value. Well....
    - sin(ypos - centre) so looks like it rotates around a cylinder.
    - Could do different scale per line. <== BONUS!
- Remove divide call from arcmusic - it's always 32767/const - DONE
- Use a proper modulo fn. for scope scroll, not a loop. - DONE
- Try having the live waveform NOT moving with the others? - DONE
- Does it look better without the flat lines on the left/right? => small border looks best.
- Dynamically cut down version for ARM2 machines? Party version can be 12MHz. - DONE AS COMPILE OPTION FOR NOW
    - Fewer samples => doesn't have much effect on overall perf => linedraw bound.
    - Fewer lines => biggest impact.
    - Need to change scopes to 8/14 :(
    - Probably also shrink text size
    - Actually switching to 32 samples for the waveform but keeping the dx=4
      makes the waveform part smaller and looks cool enough!
      Can reduce scopes to 11/11 or higher!
- Dynamically set sample speed for ARM2/ARM250+ machines for highest quality.
    - DONE AS COMPILE OPTION FOR NOW

Line segment drawing.
dx is fixed == 4 (or whatever)
dy limited: -128 <= dy <= 127
Line segments are connected.

Use MODE 12.
Unroll all 256 possible code paths.
Just do Bresenham, steep and shallow paths with
x+=1:y+=0 => strb r4, [r11], #1
x+=1:y+=1 => strb r4, [r11], #-ScreenStride+1
x+=1:y-=1 => strb r4, [r11], #ScreenStride+1
x+=0:y+=1 => strb r4, [r11], #-ScreenStride
x+=0:y-=1 => strb r4, [r11], #ScreenStride

Fantasy Cracktro Compo
~~~
Target 16th March ~five weeks!
Use RasterMan => music bug? (See Steve's email)
Get a chip tune => get something running first
Sine scroller => started
Add rasters => started
    - Raster bars?
Some ASCII text effect
Something in the background?
    - Starfield?
    - 3D starfield?
    - Particle system of some sort?
    - Line effect of some sort?
Logo! => Ask on the Atari forum if Jade will make one?


Scroller
- MODE 9 for raster colours.
- 1 byte columns = 2 pixel scroll, not per pixel
- 16x16 font = 1 byte x 16 rows x 8 x cols

ldmia r11!, {r0-r3}     ; 16 bytes
strb r0, [r12], #160
mov r0, r0, lsr #8
strb r0, [r12], #160
...
; repeat x16

Rasters
Classic hue table
R > Y > G > C > B > M > R
0x00f > 0x0ff > 0x0f0 > 0xff0 > 0xf00 > 0xf0f > 0x00f

ASCII text
- 8x8 font plotting say 20x16 ish to the screen for messages.
- Text types out one character at a time.
- Start by plotting in fixed location
- Add movement
     - Per character? => SLOW as has to be masked (4x RAM access)
     - Or somehow per pixel?

What do we want the effect to be?
If not separate characters could blit to a texture buffer.
Then how to get the texture to the screen.
Moving as a single fixed block isn't interesting.
    - Trivial on Amiga as this will be on a separate bitplane.
Ideally would want it mapped to a nice 'flag'
    - Alternatively make text out of particles cf. Push
    - Some sort of 5x7 font made out of independent dots.
    - Max 35 points, but average say 16 points?
    - Push uses 500 particles per frame = ~30 letters.
    - Hmm, not really enough. TextBox current 24x12=288 chars.

Or do something more like Hoffman's Cracktro text effect?
So use the whole high-res screen (80 column) but fixed.
That'd be in MODE 12? => Double pixels for the scroller (twice the cost...)
Would need to plot these to a third buffer and blit it instead of CLS.
Don't want to be plotting 80x32 chars individually each frame.
=> Ask ne7 for some ASCII screens!
Maybe have enough time to blit some sprites on top (vector balls ish?)
==> ALL TOO SLOW :(

Regroup
~~~
Trying to ape bitplanes on Archie is a path to madness!!!
E.g. just having a screen of static text behind everything else is
trivial on Amiga (1 independent bit plane) but painful on Archie as
everything has to be masked.

Really need to focus on what Archie is good at - not bitplanes!!

If using RasterMan then let's explore this more.
Not tried the MEMC writes to change screen address per line.
=> Wibbling logo 'for free' by selecting from preshifting 16 copies (one byte each)
=> Wibbling reflection plane at bottom of the screen by selecting from main screen

MEMC writes - can't set VInit other than on new frame.
But can set VStart and VEnd!
When Vptr > VEnd then wraps to VStart.
Vptr+=1 => 16 bytes.
All addresses are physical RAM.
Thankfully VStart typically = 0x0000
VEnd = 0x13ff = 2 * 0xA00 - 1 = 2x 40K screens - 16 bytes

==> Separate ponder. I wonder if it's possible to VRup the VIDC?
A: No! VSync always happens when Vcounter resets to 0.
   (But you can reset a load of registers midframe anyway.)
    https://stardot.org.uk/forums/viewtopic.php?p=425369 

How about a large lit torus clipped with a header logo and a scroller text below?
=> YES! :)

Cross product.
| i  j  k  |
| x0 y0 z0 |
| x1 y1 z1 |

i (y0*z1) - (z0*y1)
-j (x0*z1) - (z0*x1)
k (x0*y1) - (y0*x1)

Then have to get the length of this and normalise. Urgh.

A = [-2.34 0.0 5.65 ]
B = [ -40.0 40.0 0.0 ]
A^B = [ -226.25 -226.25 -93.75 ]

Ring starts rhs X+ve Y=0 goes down
Circle starts outer edge Z=0 X+ve Y+ve goes inside

(outside edge) 0 1 (bottom edge) 2 3 (inside edge) 4 5 (top edge) 6 7 (outside edge)
So draw order would be: 3 4 2 5 1 6 0 7
Could rotate these 180 degrees: 0 7 1 6 2 5 3 4
0 N-1
i DIV 2 (N-1)-(i DIV 2)

- Coordinates are upside down? (Y inverted?) - FIXED
    => Check transformed verts on frame 0.
       Looks like Y is upside down? YES. FFS.
    => Move to Sarah's matrix transform for verts. - DONE

- Face normals pointing the wrong way?! - FIXED
    => Check winding order! - DONE

- Performance
    => largest torus at 50Hz at 8MHz? ==> NOT MUCH!
    => cheaper scroller?
    => all micro-optimisations in loop - DONE
- Sorting
    => create front and back facing presorted face list
    => pick face list based on direction torus is pointing

Sarah's vertex transform code.
~~~
Precision is possibly s7.12

; R14=count (down)
transform_loop:
        LDMIA r12!, {r9, r10} ;x, y
        ORR r12, r14, r12, LSL #11  ; count | src_ptr << 11 (free up r14)

        ;r0-r8 - matrix
        ;r9, r10 - x, y
        ;r11 - temp
        ;r12 - source ptr
        ;r14 - temp

        MUL r11, r9, r6   ;z=x*m20 + y*m21
        MLA r11, r10, r7, r11

        MUL r14, r10, r1  ;x = y*m01

        MUL r10, r4, r10     ;y = y*m11
        MLA r10, r3, r9, r10 ;y = x*m00 + y*m11

        MLA r9, r0, r9, r14 ;x = x*m00 + y*m01

        MOV r14, r12, LSR #11   ; extract src_ptr
        LDR r14, [r14]  ;z
        ADD r12, r12, #4<<11    ; increment embeded src_ptr

        MLA r9, r2, r14, r9   ;x = x*m00 + y*m01 + z*m02
        MLA r10, r5, r14, r10 ;y = x*m01 + y*m11 + z*m12
        MLA r11, r8, r14, r11 ;z = x*m02 + y*m21 + z*m22        

        MOV r14, r12, LSL #(32-11)
        MOV r14, r14, LSR #(32-11)  ; extract count
        MOV r12, r12, LSR #11       ; extract src_ptr

        MOV r9, r9, ASR #12         ; s7.12 after MUL
        MOV r10, r10, ASR #12
        MOV r11, r11, ASR #12
        STMDB sp!, {r9, r10, r11}   ; push on stack

        SUBS r14, r14, #1
        BNE transform_loop

Perf more broadly?
~~~
Triangle strip approach?
Read a list of verts interleaved with colour word to plot?
=> 2D or 3D? 2D verts ultimately have to be sorted top-to-bottom
Will the cost of writing this out be higher than doing it inline?
Perhaps reduces register pressure?
Worth testing but in harness...

Or! Think about a display list approach?
As we're using a presorted mesh the face order is consistent.
So after projection the quad loop is always the same.
Modulo the visibility check.

Compile the mesh into something that is 'executable'.
Could have a list of bytecodes commands that are interpretable
E.g. Draw triangle, draw strip, set colour etc.

Or just compile this to actual executable code?
What does the plot loop boil down to?

; R2=ptr to projected vertex array (x,y) in screen coords
; R10=ptr to visibility array
; R11=ptr to face colour array

; Read the visibility check.
ldrb r1, [r10, #face_no]     ; read visibility check
cmp r1, #0
beq .1

; Read the three verts for a triangle.
ldr r3, [r2, #t0_v1o + 0]    ; v1x = triangle 0, vertex 1 index offset
ldr r4, [r2, #t0_v1o + 4]    ; v1y = triangle 0, vertex 1 index offset

ldr r5, [r2, #t0_v2o + 0]    ; v2x = triangle 0, vertex 2 index offset
ldr r6, [r2, #t0_v2o + 4]    ; v2y = triangle 0, vertex 2 index offset

ldr r7, [r2, #t0_v3o + 0]    ; v3x = triangle 0, vertex 3 index offset
ldr r8, [r2, #t0_v3o + 4]    ; v3y = triangle 0, vertex 3 index offset
; ^-- the above could be optimised where vertices are Consecutive

add r9, r2, #tN_vMo
ldmia r9!, {r3-r4, r5-r6}    ; if consecutive etc.

ldr r9, [r11, #face_no]     ; read colour word
bl triangle_plot_ex

; Triangle plot routine trashes all registers!
; So need to reload the base ptr.
; Could structure the data so there's just one base ptr.
; As long as the number of faces is fixed (or just set max)

ldr r2, runtime_base_ptr
; Eg. visibility array [MAX_FACE bytes]
;     face colour array [MAX_FACE words]
;     projected vertex array [MAX_VERTS*2 words]

.1:

Ideally would generate this code at runtime.
But harder to fully optimise.
Would need to patch up branches, but not too bad.
Is reading two consecutive words faster with ldm?
3c + 1.25c per reg = 3 + 2*1.25 = 3 + 2.5 = 5.5c + add at 1c = 6.5c
Instead of 2x4c = 8c so yes!

What does this save us?
Per visible face:

    stmfd sp!, {r9-r12}         ; 8c
    orr r4, r4, r4, lsl #4      ; 1c
    orr r4, r4, r4, lsl #8      ; 1c
    orr r4, r4, r4, lsl #16     ; 1c
    mov r1, r3                  ; 1c
    and r0, r1, #0x0ff          ; 1c
    mov r0, r1, lsr #8          ; 1c
    and r0, r0, #0x0ff          ; 1c
    mov r0, r1, lsr #16         ; 1c
    and r0, r0, #0x0ff          ; 1c
    stmfd sp!, {r1, r2}         ; 5.5c
    mov r0, r1, lsr #24         ; 1c
    and r0, r1, #0x0ff          ; 1c
    ldmfd sp!, {r9-r12}         ; 5.5c

Total = 11c + 11c + 8c = 30c per face. :S
Large torus = 64 faces = 32 faces visible = 960c.
Not a lot! < 2 scanlines.

Could save some of this anyway by blowing out the mesh arrays?
Face colour => colour word.
Quad face indices => store as words.

Megademo TODO
~~~
PREP
- One makefile produces two exes
- Each exe has a different set of assets and music.
- Each exe has a separate sequence script.
- All other code is shared.
    - In theory only need to swap the app.asm file!!
=> Hedge against Megademo not happening, pending other folks actually committing.
=> Keep as a single exe for now, probably only a couple of hours work to separate exes.
=> Takes more effort to maintain two.

UV PART
- Move from proto-arc repo into archie-verse. - DONE
- Add 8 initial tables.
    => Paul to the rescue!
- Add 8 initial textures.
- Add 8 initial colour palettes.
- Make a simple sequence that just cycles through them. - DONE
- Make a sequence with energy and sync:
    - Something a bit more acid like?
    - Fast switch to the beat.
        => Note that unrolled code is large and generating tables is slow.
    - Change direction quickly to the beat.
    - Animated texture to the beat.
- Add music.
- Move to new features
    - Skip pixels - DONE
    - Animated textures?
    - Colour cycling?
    - Scroller?
    - Additional FX e.g. plasma? <= No time!
    - Transitions
        - Smoothly appear one/two lines at a time.
        - Palette fade.
        - Wipe the texture instead of the screen.
        ==> Create jump table with call points per line plotted.
    - Generate tables at runtime?
        (Requires sqrt, atan2, sin, cos functions)
- Polish!

DONUT PART
- Add logo. - BODGED
- Add scroller.
    - Scroller at 50Hz how?
        - Update on vsync - STARTED
        - Use RasterMan to display a separate buffer?
- Come up with at least four interesting variations.
    - Move
        - Defining paths with individual math_vars is tedious.
          Now need to define a math_vec_func !? - DONE
          Could also have a 'move to target' tick? - STARTED
    - Morph
    - Animate
        => Need to be careful with sorting order
           (Or implement face sorting.)
           E.g. twisting the verts will invalidate the static draw order.
        - Copy mesh header for animated version of the mesh.
        - Create a new vert array and update ptr in header.
        - Animated verts into a new verts array from base vert array.
        - Update mesh ptr in the entity being displayed...
    - Lighting
        - Move the light source - DONE
        - Multiple light sources? => NOT ENOUGH COLOURS?
        - Draw the light source
    - Triangle wibble by offseting X start by Y index into table..
- Colours
    - Some nicer palettes.
    - Some palette blends.
    - What about dithering?
    - Any sync?
- RasterMan for logo and scroller?
    => Need vsync callback to run != 50Hz

To make it a demo?
- Intro splash
- Credits
- Greets
- Transitions
- Tune
- Size code down to 64Kb?
- RasterMan or not? (Can't be 64Kb currently - need TinyQTM RM edition.)
- Could also switch to 320x180 screen if desperate?


---
I wanna make another acid demo!!
---

Riffing with Paul
~~~
screen[i++] = texture[0x23f5]
screen[i++] = shade_table[texture[0x23f5] + shade_const]
screen[i++] = texture[0x23f5] >> (tint_bit)
screen[i++] = texture[0x23f5] | (tint_bit)
screen[i++] = texture[0x23f5] & ~(tint_bit)

Store different version of the texture in the top nibble.
Masking code is altered to mask and shift the correct nibbles.

Scheme 1:
#define MAT_GRID 1
#define MAT_REFLECT 2
#define MAT_REFRACT 4
#define MAT_STREAKS 8
#define MAT_SHADOW 128

Scheme 2:
logical_colour = texture[uv]
logical_colour = (logical_colour >> a) + b

#if SCENE == SHIP_SCENE
// https://gradient-blaster.grahambates.com/?points=000@0,022@4,58c@11,fff@15&steps=16&blendMode=oklab&ditherMode=blueNoise&target=amigaOcs&ditherAmount=40
    int PaletteData[] = int[](
	0x000,0x000,0x000,0x011,0x022,0x123,0x134,0x246,
	0x357,0x469,0x47a,0x58c,0x7ad,0xace,0xdef,0xfff    
    );
#else
    // https://gradient-blaster.grahambates.com/?points=000@0,a61@8,fff@15&steps=16&blendMode=oklab&ditherMode=blueNoise&target=amigaOcs&ditherAmount=40

    int PaletteData[] = int[](
    	0x000,0x100,0x110,0x310,0x421,0x530,0x740,0x950,
        0xa61,0xb84,0xc86,0xda8,0xdb9,0xedb,0xfee,0xfff
    );
#endif    

=> Need a cheap fade for the tunnel / distance modifier
    - Use Paul's shift and add approach?
        - Can try this in Python easily enough to see what it looks like..
    - Bake 2x2 dithering into the plot routine.
        - Hard mask the pixels (not) to be plotted.
            bic rDest, rDest, #0xf0f0f0f0 etc.
    - Use two textures interleaved for a darkened version
    - Use four separate textures - replace the four pointers
        with tracked add/sub instructions.
    ==> Paul might make the tunnel FX anyway...

RAM budget
- Assume 9 parts?
- Each has UV table = 60K max
- Each has unique texture = 16K
- Max = 9*60 = 540K + 9*16 = 144K = 684K
- Plus unrolled code = 328K
- Plus sinetable = 64K (could be shrunk or just use smaller 32K table?)
- Plus runtime texture space = 32K (2x16K for wrap in V)
- Plus ZP/loader = 64K
- Plus MOD :) = current 196K but let's see if we can get that up!
- Plus code + stack = 32K max (probably 16K)
- 1400K available total (can be stretched for onetime execution)

- Plus modules in memory (QTM + RAM)
- Plus screen buffers
- Plus RISCOS overhead :S

Runtime RAM savings:
- Double up texture being used when switching to it (requires double copy to scratch)
    - 9*16K + 32K scratch = saves 112K
- Compress UV tables somehow?


TODO:
- Add Hz debug counter. - DONE
- Add Paul's new UV tables and textures. - DONE
- Separate the two parts. - DONE
- Sort out RAM. - DONE
- Add configurable texture size at runtime. - DONE
    - Pass through UV's in conversion, don't munge them. - DONE
    - Set texture dims in script - DONE
    - Update code gen to accomodate texture dim calc. - DONE
- Sort out time in script as ARM2 runs much slower than ARM250!! :|
- Fix index textures to properly pass through... (DiskIndex bug) - DONE
- Export new U,V,S format from old UV table Python script. - DONE
- Test decompressing LZ4 UV tables at runtime. - DONE saves 300K!

- Compress UV tables to reduce RAM overhead? - DONE
    - Doing U,V deltas increases the compressability.
    - LZ4 works surprisingly well.
    - Would have to see if the overall saving was enough to decomp into a scratch buffer..
        E.g. paul[1-5] comes to ~140 with LZ4 or 260K w/out so would save 60K even with 60K buffer.
        Depends on how we're transitioning between scenes?
    - Could do a RLE type scheme, but might be better to use a generic compressor
     (otherwise the decompress and codegen gets complicated)

For Megademo:
- Load and run at 0x10000 - DONE
    - Change .org
    - Update link_script.txt
- Build creates both binaries? - DONE
- Minimal binary for each part. - IN PROGRESS
- Compress binaries. => Sarah to choose method.

Fix frames / vsyncs / seconds once and for all:
- vsyncs (every 50Hz)
- frames (once around the main loop - frames displayed to user)
- seconds = vsyncs / 50

vsync_count used for:
- test for frame drops (when 50Hz) - DEBUG
- calculating frame rate - DEBUG
- LuaPod and RocketPod time communication with host

vsync_delta used for:
- script wait vsyncs - so that transitions match music
- passed in as R1 to FX tick fns (but not used?)

frame_counter used for:
- overall length of the demo 'max_frames'
- sync tracks (LuaPod) - UNUSED
- passed in as R0 to FX tick fns (but not used?)
- fast forward to frame when skipping music patterns - DEBUG

desirata:
- sequence scripting specified in seconds (which matches the MOD / wall clock)
- math_vars should be updated per vsync
- scripts are ticked once per frame

==> SHORTEST PATH: Update math_vars by delta_vsyncs...

So Ship -> Planet -> Black Hole -> Tunnel -> Trippy stuff -> Reactor Panic -> Reactor Safe 
